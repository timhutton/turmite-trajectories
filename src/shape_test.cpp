// Local:
#include "defs.h"
#include "line.h"
#include "write_bmp.h"

// C++ Standard Library:
#include <algorithm>
#include <chrono>
#include <cstdlib>
#include <cinttypes>
#include <iostream>
#include <random>

/*

Do a (vN) random walk from a point on the edge of an area. If crosses the x-axis then start again.
If hits the curved wall then accumulate there and start again.

We want to check whether all points on the curved path are hit with equal probability.

*/

const double measured_llrr_radial[181]={1,1.003365683,1.005434206,1.00684812,1.008891366,1.009639134,1.011655588,1.013019178,1.013415966,1.015077452,1.015088911,1.015782549,1.017104369,1.017724254,1.018025931,1.01863815,1.018853558,1.019160225,1.018363306,1.018893894,1.019020727,1.018438889,1.018165667,1.017905322,1.01795829,1.017897196,1.017424775,1.01697323,1.016399528,1.016134151,1.01545964,1.013937315,1.013439788,1.013249811,1.0126546,1.01192265,1.009891885,1.00862017,1.009070278,1.007966787,1.006062515,1.005124431,1.004283637,1.00238423,1.001698137,0.999953577,0.998970169,0.997150073,0.99517768,0.994416698,0.991900596,0.990591538,0.989132123,0.987526396,0.985707773,0.983736874,0.982778741,0.980696062,0.97819741,0.975998023,0.973821432,0.972098209,0.969794589,0.968223639,0.965511762,0.962943434,0.960530732,0.958120856,0.955411144,0.952991577,0.951276487,0.948119362,0.944948681,0.942163503,0.939573058,0.937051695,0.934191237,0.93129918,0.929003235,0.926046635,0.922999469,0.920664074,0.917285857,0.914548705,0.910454689,0.907313058,0.904449197,0.901561445,0.897648132,0.894993999,0.890996785,0.887594006,0.884140304,0.880622457,0.877691534,0.873747577,0.87004501,0.866570462,0.863081448,0.859131555,0.855441084,0.852013404,0.847459846,0.842849611,0.839438505,0.835187881,0.83127485,0.827129654,0.82323314,0.819180158,0.815073726,0.810392608,0.806256616,0.801649763,0.797585621,0.793633881,0.788774884,0.784155841,0.779346138,0.774905471,0.769701179,0.765567576,0.760505902,0.755232914,0.750907613,0.745474729,0.740793865,0.736786463,0.731654344,0.726547236,0.721456641,0.71658515,0.711267974,0.705260737,0.700393437,0.694829043,0.688795591,0.684104817,0.678477012,0.673057947,0.667812916,0.661616174,0.656525974,0.650933877,0.645475948,0.63905359,0.633276457,0.627161331,0.620695223,0.614417207,0.608933012,0.602915841,0.596804142,0.590454916,0.583850584,0.576849233,0.57058555,0.564790333,0.55828307,0.551465788,0.544096769,0.536595451,0.529467577,0.523208731,0.51547781,0.507993506,0.500356672,0.494040225,0.485533208,0.476928658,0.468847889,0.460014456,0.452003577,0.4428568,0.433246901,0.422841808,0.411927728,0.400866763,0.388337786,0.372081302,0.349517685}; // [0,180] degrees from small indentation, measured after 1 trillion steps using llrr.cpp

const double measured_random_walk_radial[181]={1,1.17663398,1.255514549,1.374788098,1.415164745,1.496503686,1.517930765,1.561380314,1.583386451,1.627923392,1.653814353,1.657413765,1.684449529,1.712181294,1.716778373,1.745538608,1.756079137,1.761653137,1.773399059,1.78592902,1.792482922,1.806158039,1.820575294,1.835717235,1.843554392,1.859749922,1.850423647,1.86779502,1.868515314,1.887350392,1.880002627,1.899938275,1.893451765,1.914452608,1.919767059,1.914753824,1.91013002,1.917663098,1.941572549,1.938401667,1.948194882,1.946022863,1.957349941,1.956171039,1.94127549,1.968807118,1.969002392,1.956171039,1.957349941,1.973683059,1.990847961,1.965973529,1.96910002,1.988239157,1.992295804,1.985433314,2.006716902,1.985142824,2.007770373,1.987368804,2.011309804,1.992102824,2.017322137,1.999327078,2.008153314,2.009014667,2.018751,2.021130216,2.006237863,2.017322137,2.021986039,2.009014667,2.021415529,2.028345843,2.017322137,2.030997765,2.021130216,2.031092412,2.022746471,2.038084157,2.030903118,2.024456392,2.038178471,2.035630333,2.031092412,2.027303059,2.043829627,2.041571039,2.040723431,2.039592725,2.039215686,2.039592725,2.040723431,2.041571039,2.043829627,2.027303059,2.031092412,2.035630333,2.038178471,2.024456392,2.030903118,2.038084157,2.022746471,2.031092412,2.021130216,2.030997765,2.017322137,2.028345843,2.021415529,2.009014667,2.021986039,2.017322137,2.006237863,2.021130216,2.018751,2.009014667,2.008153314,1.999327078,2.017322137,1.992102824,2.011309804,1.987368804,2.007770373,1.985142824,2.006716902,1.985433314,1.992295804,1.988239157,1.96910002,1.965973529,1.975824667,1.973683059,1.957349941,1.956171039,1.969002392,1.968807118,1.94127549,1.956171039,1.957349941,1.946022863,1.948194882,1.938401667,1.941572549,1.917663098,1.91013002,1.914753824,1.919767059,1.914452608,1.893451765,1.899938275,1.880002627,1.887350392,1.868515314,1.86779502,1.850423647,1.841989627,1.843554392,1.835717235,1.820575294,1.806158039,1.792482922,1.78592902,1.773399059,1.761653137,1.756079137,1.726603922,1.716778373,1.712181294,1.684449529,1.657413765,1.653814353,1.627923392,1.583386451,1.561380314,1.517930765,1.496503686,1.434726137,1.374788098,1.27511298,1.157028902,1}; // [0,180] degrees, measured using walk_plot.cpp

bool inMoore(int x,int y,int tx,int ty) { return abs(x-tx)<=1 && abs(y-ty)<=1; }
bool onGrid(int x,int y,int X,int Y) { return x>=0 && x<X && y>=0 && y<Y; }
int dist2(int x,int y,int sx,int sy) { return (x-sx)*(x-sx)+(y-sy)*(y-sy); }

int main()
{
    const int X = 1000;
    const int Y = 600;
    int chain_idx[Y][X];
    const int sx = X/2;
    const int sy = 0;
    int x = sx;
    int y = sy;
    const int N_DIRS = 4; // NESW
    const int dx[N_DIRS] = {0,1,0,-1};
    const int dy[N_DIRS] = {-1,0,1,0};
    const int dx8[8] = { 0,1,1,1,0,-1,-1,-1 };
    const int dy8[8] = { -1,-1,0,1,1,1,0,-1 };

    std::vector<uint64_t> impacts;

    // clear the arrays
    for (int fy = 0; fy < Y; fy++) {
        for (int fx = 0; fx < X; fx++) {
            chain_idx[fy][fx] = -1;
        }
    }

    // initialize chain
    int ax = 0;
    int ay = 0;
    for(int theta=0;theta<=180;theta++)
    {
        const double rad = theta * PI / 180.0;
        //const double r = X/3 * measured_llrr_radial[theta];
        //const double r = X/4 * measured_random_walk_radial[theta];
        //const double r = X/4; // semi-circle
        const double r = X/4 * (1+(measured_random_walk_radial[theta]-1)/3); // reduced version of the measured walk_plot
        int bx = std::clamp((int)round(sx + r * cos(rad)),0,X-1);
        int by = std::clamp((int)(1.2*round(sy + r * sin(rad))),0,Y-1);
        if(theta>0) {
            line(ax, ay, bx, by, [&](int x,int y) {
                if(chain_idx[y][x]==-1) {
                    chain_idx[y][x] = (int)impacts.size();
                    impacts.push_back(0);
                }
            });
        }
        ax = bx;
        ay = by;
    }

    // draw the chain for debugging
    write_bmp("shape_test_chain.bmp",X,Y,[&](int x,int y,unsigned char bgr[3]) {
        if( chain_idx[y][x] > -1 ) { bgr[0]=bgr[1]=bgr[2]=255; }
        else { bgr[0]=bgr[1]=bgr[2]=0; }
    });

    std::random_device rd;  //Will be used to obtain a seed for the random number engine
    std::mt19937 gen(rd()); //Standard mersenne_twister_engine seeded with rd()
    std::uniform_int_distribution<> random_move(0, N_DIRS - 1);

    auto t1 = std::chrono::high_resolution_clock::now();

    uint64_t iterations = 0;
    for(; iterations<10*billion; ++iterations)
    {
        int dir = random_move(gen);
        int new_x = x + dx[dir];
        int new_y = y + dy[dir];
        if(new_y<0)
        {
            // start afresh
            x = sx;
            y = sy;
            continue;
        }
        /*if (!onGrid(new_x, new_y, X, Y)) // DEBUG
        {
            std::cerr << "Moved off grid" << std::endl;
            exit(EXIT_FAILURE);
        }*/
        int iChain = chain_idx[new_y][new_x];
        if( iChain >= 0) {
            // make a note of the impact and start afresh
            impacts[iChain]++;
            x = sx;
            y = sy;
            continue;
        }
        else {
            // take the step
            x = new_x;
            y = new_y;
        }
    }

    auto t2 = std::chrono::high_resolution_clock::now();
    std::cout << iterations << " steps took: "
              << std::chrono::duration_cast<std::chrono::seconds>(t2 - t1).count()
              << " seconds\n";

    // output the impact counts to console
    for(uint64_t c : impacts) { printf("%" PRIu64 " ",c); }
    printf("\n");

    return EXIT_SUCCESS;
}
